<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Favorite Ruby Tips &amp; Tricks</title>
    <url>/2024/04/25/2024-04-25%20Favorite%20Ruby%20Tips%20&amp;%20Tricks/</url>
    <content><![CDATA[<h3 id="Conditional-Method-Chaining"><a href="#Conditional-Method-Chaining" class="headerlink" title="Conditional Method Chaining"></a>Conditional Method Chaining</h3><p>Method Chain을 조건에 따라 조정하는 경우가 있습니다.</p>
<p>예를 들자면 아래와 같이 조건에 따라 유저 목록을 필터링해서 가져오는 경우를 들어 볼 수 있겠어요.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">name, email = params.values_at(<span class="symbol">:name</span>, <span class="symbol">:email</span>)</span><br><span class="line"></span><br><span class="line">user = <span class="title class_">User</span>.all</span><br><span class="line">user = user.name_like(name) <span class="keyword">if</span> name</span><br><span class="line">user = user.email_like(email) <span class="keyword">if</span> email</span><br><span class="line">user = user.page(page_params[<span class="symbol">:page</span>]).per(page_params[<span class="symbol">:per</span>])</span><br></pre></td></tr></table></figure>

<p>then Enumerator를 이용해서 조금 더 FP 스러운 느낌을 내 볼 수 있어요.<br>이쪽이 조금 더 가독성이 좋다고 느끼는 편입니다.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">name, email = params.values_at(<span class="symbol">:name</span>, <span class="symbol">:email</span>)</span><br><span class="line"></span><br><span class="line">users = <span class="title class_">User</span>.all</span><br><span class="line">            .<span class="keyword">then</span> &#123; |<span class="params">users</span>| name ? users.name_like(name) : users &#125;</span><br><span class="line">            .<span class="keyword">then</span> &#123; |<span class="params">users</span>| email ? users.email_like(email) : users &#125;</span><br><span class="line">            .page(page_params[<span class="symbol">:page</span>])</span><br><span class="line">            .per(page_params[<span class="symbol">:per</span>])</span><br></pre></td></tr></table></figure>

<p>then은 최상위 Object에 구현되어있는 method라서 NilClass도 가지고 있습니다.<br>nil guard 없이도 편하게 사용할 수 있는 장점이 있어요.</p>
<h3 id="Optional-Element-in-Array-Hash"><a href="#Optional-Element-in-Array-Hash" class="headerlink" title="Optional Element in Array &amp; Hash"></a>Optional Element in Array &amp; Hash</h3><p>Flag에 따라 Array나 Hash에 Element를 넣거나 없애고 싶을 때 one-liner로 정리 할 수 있어요.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">flag?</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">array = [</span><br><span class="line">  <span class="string">&quot;1st element&quot;</span>,</span><br><span class="line">  *(<span class="string">&quot;2nd element&quot;</span> <span class="keyword">if</span> flag?),</span><br><span class="line">  <span class="string">&quot;3rd element&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># =&gt; [&quot;1st element&quot;, &quot;3rd element&quot;]</span></span><br><span class="line"></span><br><span class="line">hash = &#123;</span><br><span class="line">  <span class="symbol">a:</span> <span class="number">1</span>,</span><br><span class="line">  **(flag? ? &#123; <span class="symbol">b:</span> <span class="number">2</span> &#125; : &#123;&#125;),</span><br><span class="line">  <span class="symbol">c:</span> <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># =&gt; &#123;:a=&gt;1, :c=&gt;3&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Hash-with-default-value"><a href="#Hash-with-default-value" class="headerlink" title="Hash with default value"></a>Hash with default value</h3><p>가끔 Tree 같은걸 만들거나 할 때 요긴하게 쓰이는 default value를 가지는 Hash를 one-liner로 만들 수 있어요.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default Value = &#123;&#125;</span></span><br><span class="line"><span class="title class_">Hash</span>.new &#123; |<span class="params">h, k</span>| h[k] = <span class="title class_">Hash</span>.new &amp;h.default_proc &#125; <span class="comment"># Infinite nested hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default Value is Your value</span></span><br><span class="line"><span class="title class_">Hash</span>.new &#123; |<span class="params">h, _</span>| h = &#123; <span class="string">&quot;foo&quot;</span> =&gt; <span class="number">0</span>, <span class="string">&quot;bar&quot;</span> =&gt; <span class="number">0</span> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>Ruby Hash는 다른 언어와는 약간 다르게 주어진 Key로 Value를 찾을 수 없을 때 기본적으로 nil을 반환하게 되어 있는데요. 이 동작을 수정하려면 Hash의 default_value를 설정해주거나, 더 fine하게 바꾸려면 default_proc을 설정해줄 수 있어요.</p>
<p>위의 예시들은 모두 default_proc을 설정해 준 케이스예요.</p>
<h3 id="Inline-rescue"><a href="#Inline-rescue" class="headerlink" title="Inline rescue"></a>Inline rescue</h3><p>간단하고 별거아닌 에러 핸들링은 inline rescue가 좀 쓸만합니다.</p>
<p>3rd gem 중에 쓸데없이 에러를 터뜨리는 것들이 있어요. 대표적으로 Python 코드를 그대로 옮겨놓은 AWS Gem이 그런데요. Ruby에서는 Array에 IndexError가 없는데, AWS Gem은 Index를 터뜨린다거나 약간 몇군데가 Python 처럼 돌아갑니다. </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">foo = <span class="title class_">Foo</span>.complex_fetching(...) <span class="keyword">rescue</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>


<h3 id="소소하지만-좋은-Enumerator"><a href="#소소하지만-좋은-Enumerator" class="headerlink" title="소소하지만 좋은 Enumerator"></a>소소하지만 좋은 Enumerator</h3><p>제가 즐겨 쓰는 Enumerator method 몇가지를 남겨둘게요</p>
<ul>
<li>times (요거 자주 씁니다 3.times { puts “Hello!” })</li>
<li>inject (숫자 더할때 많이..)</li>
<li>each_with_object (요게 js의 reduce와 좀 비슷한 느낌이라 가끔씩)</li>
<li>with_index (인덱스가 안달리는 경우가 있을때 체인 걸어서 쓸 때가 가끔씩)</li>
<li>each_with_index</li>
<li>tap (Enumeration 돌때마다 뭔가를 터치할때 요긴한데, 생각보다 쓸데가 없는.. 하지만 유용한 순간엔 유용한..)</li>
</ul>
<h3 id="tally"><a href="#tally" class="headerlink" title="tally"></a>tally</h3><p>Ruby 2.7 에 새로 생긴 소소한 method 중 tally 가 있습니다. 간단한 group count method 인데요. 간단한 CS 문의를 봐줄 때나, 통계 데이터 뽑을 때 요긴하게 쓰고 있습니다.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bad_user_ids = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">1</span>]</span><br><span class="line">bad_user_ids.tally</span><br><span class="line"><span class="comment"># =&gt; &#123;10=&gt;1, 11=&gt;3, 12=&gt;1, 15=&gt;2, 13=&gt;1, 14=&gt;1, 1=&gt;2, 2=&gt;1&#125;</span></span><br></pre></td></tr></table></figure>


<h3 id="Method-Digging"><a href="#Method-Digging" class="headerlink" title="Method Digging"></a>Method Digging</h3><p>런타임 시점에 만들어진 Method의 이름과 위치를 알아내는 테크닉에 대해 소개합니다.</p>
<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>가끔 어떤 클래스에 어떤 메서드가 실제로 존재하는지 직접 확인해야 하는 경우들이 생기곤 합니다.</p>
<p>왜냐면 소스코드에는 없지만, 런타임에 갑자기 메서드가 생기는 경우들이 있으니까요. </p>
<p>ps. 메타프로그래밍은 훌륭한 도구이지만 다음 사람을 위해 메서드 시그니쳐를 타이핑해주거나 주석 정도는 남기도록 해요….</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">User</span>.methods <span class="comment"># 이 클래스의 클래스 메서드 이름들을 Array of symbol로 리턴합니다.</span></span><br><span class="line"><span class="title class_">User</span>.instance_methods <span class="comment"># 이 클래스의 인스턴스 메서드 이름들을 Array of symbol로 리턴합니다.</span></span><br></pre></td></tr></table></figure>

<p>그런데, User 라는 ActiveRecord Class는 엄청 많은 클래스와 모듈을 상속 &#x2F; 믹스인 받아온 상태라 우리가 알고 싶지 않은 메서드 이름을 까지 리턴해주게 돼요.<br>심플하게</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">User</span>.methods - <span class="title class_">Object</span>.methods</span><br></pre></td></tr></table></figure>
<p>또는</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">User</span>.methods - <span class="title class_">ApplicationRecord</span>.methods </span><br></pre></td></tr></table></figure>
<p>이정도로 Ancestor methods들을 제거해서 볼 수 있습니다. 혹은 User.ancestors 를 통해 이 클래스의 Ancestor chain 을 확인해 본 다음에 원하는 위치부터 method를 제거해 볼 수 도 있겠어요.</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>메서드의 이름을 찾아냈다면, 이제 그 메서드가 어디에 있는지, 어떤 코드를 가지고 있는지도 찾아 볼 수 도 있습니다.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title class_">User</span>.method(<span class="symbol">:find</span>)</span><br><span class="line"><span class="comment"># =&gt; #&lt;Method: #&lt;Class:User(...)&gt;(ActiveRecord::Core::ClassMethods)#find(*ids) /.../activerecord-6.1.7.7/lib/active_record/core.rb:337&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">User</span>.method(<span class="symbol">:find</span>).source</span><br><span class="line"><span class="comment"># 진짜 find method의 소스 코드를 출력해줍니다.</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">User</span>.method(<span class="symbol">:find</span>).source_location</span><br><span class="line"><span class="comment"># [&quot;/.../activerecord-6.1.7.7/lib/active_record/core.rb&quot;, 337] 몇번째 파일 어디 라인인지 알려줍니다.</span></span><br></pre></td></tr></table></figure>


<h3 id="Ruby-Binding"><a href="#Ruby-Binding" class="headerlink" title="Ruby Binding"></a>Ruby Binding</h3><p>사실 실무를 하면서 쓸일이 있나 싶기는 하지만..</p>
<p>Rails 온보딩을 해드리면 종종 받는 질문 중 하나라서 남겨봅니다.</p>
<p><code>app/controllers/users_controller.rb</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UsersController</span> &lt; <span class="title class_ inherited__">ApplicationController</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">show</span></span><br><span class="line">    <span class="variable">@user</span> = <span class="string">&quot;Robin&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>app/views/users/show.html.erb</code></p>
<figure class="highlight irb"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Hi</span> &lt;%= <span class="variable">@user</span> %&gt;!</span><br></pre></td></tr></table></figure>

<p>어떻게 erb는 @user를 알아서 Robin으로 바꿔치기 해가는 걸까요?</p>
<p>옛날 옛적 Spring의 경우 ModelAndView 객체에 명시적으로 담아가게 되어있는데, Rails엔 그런게 다 생략 되어 있죠.  erb의 instance variable 바꿔치기 를 설명하기 전에 binding에 대한 이야기를 잠깐 소개 하고 갈게요.</p>
<p>Ruby는 Javascript와 비슷하게 Context Binding 개념이 있는데요. 그레서 Lexical Scope라는 표현을 종종 사용하곤 합니다.  이 얘기는 너무 기니깐.. 아래 처럼 Lexical Scope을 맘대로 바꿀 수 있습니다. 진짜 Javascript 느낌이 나죠..?</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;robin&quot;</span></span><br><span class="line">eval(<span class="string">&quot;puts name&quot;</span>, binding) <span class="comment"># robin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_binding</span></span><br><span class="line">  name = <span class="string">&quot;llama&quot;</span></span><br><span class="line">  binding</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">eval(<span class="string">&quot;puts name&quot;</span>, get_binding) <span class="comment">#llama</span></span><br></pre></td></tr></table></figure>

<p>다시 돌아와서, erb는 아래와 같은 방식으로 interpolation을 합니다. (많이 축약해놨어요.)</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UsersController</span> &lt; <span class="title class_ inherited__">ApplicationController</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">show</span></span><br><span class="line">    <span class="variable">@user</span> = <span class="string">&quot;Robin&quot;</span></span><br><span class="line">    </span><br><span class="line">    erb = <span class="variable constant_">ERB</span>.new(<span class="string">&quot;Hi &lt;%= @user %&gt;!&quot;</span>) <span class="comment"># 실제로는 convention에 의해 Controller#Action과 같은 위치의 ERB 파일을 읽어옵니다.</span></span><br><span class="line">    render <span class="symbol">html:</span> erb.result(binding) <span class="comment">#그리고 이 컨트롤러의 lexical scope을 그대로 erb 객체에게 넘겨줍니다. </span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="Instance-debugging"><a href="#Instance-debugging" class="headerlink" title="Instance debugging"></a>Instance debugging</h3><p>Ruby는 클래스의 모든 부분에 있어 열려있습니다. 런타임에 변수나 메서드를 지우고, 새로 만들고, 덮어씌울 수 있습니다.  루비를 꽤 오래 써 온 저한테는 조금 익숙한 개념인데, 지금 잠깐 생각해보니 “그래도 되는거야..?” 싶은 개념 인 것 같기도 하네요. </p>
<p>여튼 이러한 맥락이 있어서 그런지, Ruby에서는 실제로는 접근제어자를 통해 접근하지 못하는 변수나 메서드도 실제로는 접근 할 수 있습니다. 이런 부분들이 가끔 디버깅 할 때 요긴하게 쓰여서 소개해드리려 합니다.</p>
<h4 id="1-private-method-call"><a href="#1-private-method-call" class="headerlink" title="[1] private method call"></a>[1] private method call</h4><p>private modifier로 보호받고 있는 method를 곧 죽어도 실행하고 싶은 경우가 가끔 있습니다.</p>
<p>그럴 땐 <code>send</code>를 이용해 호출 할 수 있습니다.  <code>foo.bar</code> 대신 <code>foo.send(:bar)</code> 요렇게요.</p>
<h4 id="2-instance-variable-get"><a href="#2-instance-variable-get" class="headerlink" title="[2] instance_variable_get"></a>[2] instance_variable_get</h4><p>보통은 attr_reader 또는 attr_accessor 같은 매크로를 통해 getter를 만들어줘야 해당 클래스 내부의 instance variable 을 외부에서 사용 할 수 있는데요.</p>
<p>사실은 강제로도 꺼내서 쓸 수 있습니다. </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">bar</span>) = <span class="variable">@bar</span> = bar</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span></span><br><span class="line">  <span class="built_in">attr_reader</span> <span class="symbol">:bar</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">bar</span>) = <span class="variable">@bar</span> = bar</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo = <span class="title class_">Foo</span>.new(<span class="number">1</span>)</span><br><span class="line">foobar = <span class="title class_">FooBar</span>.new(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">foo.bar <span class="comment"># It raises NoMethodError</span></span><br><span class="line">foobar.bar <span class="comment"># 1</span></span><br><span class="line">foo.instance_variable_get(<span class="symbol">:</span><span class="variable">@bar</span>) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>사실 RubyMine 디버거가 있어서 쓸 일이 자주는 없지만, 특정 구현체 하나만 가지고 콘솔에서 디버깅을 할 때에는 이게 좀 유용합니다.</p>
]]></content>
      <categories>
        <category>rails</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>Rails</tag>
      </tags>
  </entry>
</search>
